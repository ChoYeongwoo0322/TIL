# 21.01.27

* OOP 객체, object?

  정의하는게 좀 어렵다고하는데, ..흠...

  예시) 

  ```
  my_lower('Hi') vs 'Hi'.lower()
  
  Hi는 함수의 인자로 들어간 것/
  문자열을 소문자로 바꾸겠다 같은 태도를 취하는중
  
  => 인자로 들어가는게 아니라 주어가 되고 동사가되는 두번째같은 형태를 말함
  ```

* 객체지향 프로그래밍

  좀더 효율적이게!  상태와 행위로 이루어짐 객체를 형성하고 레고블럭처럼 조립해서 하나의 프로그램을 형성함. 그러므로 객체지향프로그래밍의 시작은 객체가 무엇인지부터 알아봐야한다.

  객체란 변수와 메서드를 하나로 묶은것

  변수는 값을 가지고 메서드는 실행코드를 가짐

  이 두개를 연관된 것들 끼리 묶어둔 것이 객체..... 띠용?

  

  * 자동차(클래스)

    * 변수 :  연료량, 속도계

    * 메서드 :  달리고 멈추는 기능(주행기능) 가면서 변수인 연료량과 속도계에 변화를 가져오게함

      ​		=> 변수와 연관된 기능

* 객체지향은 부품으로 잘 만든 레고와 같은데, 한 군데서만 사용되는게 아니라 여러곳에서 재사용가능

  * 부품화
  * 재사옹성

* 클래스! : 부품 객체를 만들기 위한 청사진, 설계도, 템플릿



## 객체지향의 구성요소

* 클래스
  * 같은 문제 도메인에 속하는 속성과 행위, 객체지향 프로그램의 기본적인 사용자 정의 데이터타입
* 객체
  * 메모리상에 생성된 정보 => 인스턴스
  * 자신 고유의 속성을 가지고 클래스에서 정의한 행위 수행
  * 클래스에 정의된 행위에 대한 정의를 공유하고 메모리를 효율적으로 사용
* 메서드
  * 메시지라고도 부르고,
  * 클래스로부터 생성된 객체 사용 시 객체에 명령을 내리는 행위



### 객체지향 프로그램의 특징

* 추상화
  * 예시) 사람이 있고, 학생들일거고 공통속성이 존재, 공통행위도 존재. 그것들을 찾아 타입을 정의하는 과정
  * 테이터 타입 = 클래스 / 인스턴스 = 객체 / 연산 = 메서드
* 상속
  * 새로만든클래스(자식, 파생, 하위, 서브) <= 기존의클래스(부모, 기반, 상위, 슈퍼)
  * 말 그대로 상속
    * 재사용으로 코드를 더 간단하게 가능함
    * 범용적인 사용 가능. object타입의 매개변수에 str int 노상관
    * 자유로운 사용 및 추가 가능
* 다형성
  * 다양한 형태
  * 클래스에 행위가 여러개, 상속도 가능하고 이것저것 사부작사부작 가능
  * 한요소에 여러개념을 넣는것
    * 오버라이딩 : 같은 이름의 메서드가 여러 클래스에서 다른 기능
      * 메서드 오버라이딩 : 하위클래스에서 새로 정의해 사용함
    * 오버로딩 : 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능
      * 메서드 오버로딩 : 동일한 이름의 행위를 여러개 정의
        * 이름은같고 매개변수 타입과 수는 달라야함

## 클래스 정의

* 클래스 정의

  class 클래스명 : 

  ....

  객체 생성

  변수 = 클래스명() = 생성자 메서드 : 클래스 이름과 동일한

  ```
  class Person:
  	pass
  	
  member = Person() # => member 객체 생성
  if isinstance(member, Person) # => 첫번째 인자의 객체가 두번째 인자의 클래스 인스턴스인지 검사
  ```



* 생성자 메서드 :  _ _ init_ _   

  * class 클래스명 :

    ​	def _ _ init _ _ (self, 매개변수목록) : # self외에는 별로 사용하지 않으니 그냥 self집어넣자

* 소멸자 메서드 : _ _ del_ _

  * class 클래스명 :

    ​	def _ _ del _ _ (self,)



### 인스턴스 메서드

* self가 가리키는 객체의 필드정보에 접근해 특정 목적 기능을 수행하도록 정의된 메서드
  * def (인스턴스 메서드)(self):

##### 인스턴스 변수

* 객체 고유의 정보
  * 캡슐화된 필드로 만들어주고 잘못될수도있음.... 이런걸 막기위해 멤버 필드의 접근 제한 필요
* 인스턴스 변수의 접근 제한 기능을 제공함
  * self.__(메서드) = name # 메서드 앞에 던더블 설정해주면 프라이빗 필드 생성됨
    * 예시를 보면, init까지는 그대로 해주고, 그 뒤에 self.__메서드 = 인스턴스?이런식으로 던더블을 적어줌 그리고 def _ get _메서드(self): 하고 return  해주면됨 요 위에거.

##### 데코레이터

* @사용해서... 변수 이름과 같은 메서드를 만들어 사용 가능함 @변수.setter

  @property

  def name(self):

  ​	return self.__name



### 클래스 변수

클래스 내에서 class.변수 로 나타남

~2505



하 너무힘들다.. 일단 중간에 keep