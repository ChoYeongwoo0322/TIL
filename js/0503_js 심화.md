# js 심화

js의 역사 - 브라우저 전쟁, 파편화&표준화

js는 브라우저를 조작하고, 문서를 조작하고, 프로그래밍언어로써 동작을하게됨(DOM, BOM, JS)

- DOM maniopulation (속성, 메서드로 조작)
- Event(브라우저 안에서 일어나는 사건들, 클릭을했을때나 스크롤이나 등등... addEventlistener로 조작함)
  - 특정이벤트가 작동하면 ~하자
- ECMAScript...변수와식별자, 타입과연산자, 조건반복,함수,자료구조 는 ppt참고(Array메서드들이 많았음)

---

### AJAX(Asynchrnous Javascript And XML, 비동기식js와 xml의 약어)

서버와 통신하기위해 XMLHttpRequest 객체를 활용함

- 동기식과 비동기식 통신을 모두 지원하면서

페이지 전체를 reload를 하지 않고서도 수행되는 ""비동기성"

- 사용자의 event가 있으면 전체 페이지가 아닌 일부분만을 업데이트할수 있음

구글맵스와지메일이 활용되는 기술을 설명하기 위해 AJAX 용어 최초로 사용함

새로운기술이 아닌 새로운 접근법(재조합)

Gmail의 예시를 보면, 메일 전송버튼 눌러두고 다른페이지로 넘어가도 메일은 알아서 전송처리가됨

새로고침 없이 url로부터 데이터를 받아올 수 있음

`장점 : 사용자가 하는것을 방해하지 않으면서 페이지의 일부를 업데이트할 수 있도록 해줌`

xml뿐만 아니라 모든 종류의 데이터를 받아오는데 사용이 가능하며

생성자 : XMLHttpRequest()

---

동기식 : 앞에것이 끝나야 진행가능

비동기식 :  앞에것이 끝나든 안끝나든 진행가능

왜? 비동기식을 사용하느냐!??

- 사용자의 경험을 증대시키기위해서,
- 만약 사전데이터가 너무 크다면? 동기식으로 작성된 데이터가 동기식이라면 로딩되는동안 앱을 사용할 수가 없음. 얼마나 걸릴지도 모르는 로딩시간을 기다려야됨(앱이 멈춘것처럼 보인다고함).... 비효율적임
- 때문에 대부분 많은 API기능은 현재 비동기 코드를 사용하고있음

- 요청을 보내고 다음코드로 넘어가서 response.data는  아무것도 나오지않는 빈문자열



---

### Threads

프로그램이 작업을 완료하는데 사용할 수 있는 단일 프로세스

각 thread는 한번에 하나의 작업만 수행가능함

예시) A > B > C

- 다음 작업을 시작하려면 반드시 앞의 작업이 끝나야됨
- cpu는 여러코어를 가지고있어서 한번에 여러가지일을 할 수 있음

---

js는 single threaded이다.

- 컴퓨터가 여러 개의 cpu를 가지고 있어도 main thread라 불리는 단일 스레드에서만 작업을 수행하고
- 즉, 이벤트를 처리하는 casll stack이 하나인 언어라는 의미임
- 하나면 비동기가..안되지않나..?
  - 이 문제를 해결하기위해 즉시 처리하지 못하는이벤트를 다른곳(Web API)로 보내서 처리하고,
  - 계속계속 처리진행하면서, 끝나면 순서대로 대기실(Task queue)에 줄을 세워 놓고
  - Call stack이 비면 담당자(Event Loop)가 대기 줄에서 가장 오래된 이벤트를 Call stack으로 보내줌

Concurrency model

- Eventloop를 기반으로 하는 동시성 모델
  - Call stack(메인 일처리를 하는 곳) - 요청이 들어올 때마다 해당 요청을 순차적으로 처리하는 stack자료
  - Web API(다른곳에서 일처리를 한다는 그 곳) - js엔진이아니라, `브라우저` 영역서 제공하는 API
  - Task Queue(끝난 순서대로 들어오는 대기실) - webapi에서 일처리가 끝난 후에 이곳에 잠시 대기하는 곳(FIFO)형태의 자료구조이며 main thread가 끝난 후에 실행되어 후속 js코드가 차단되는 것을 방지해줌
  - Event Loop(담당자)
